[{"content":"","date":"3 April 2024","permalink":"/tags/dispatcher-servlet/","section":"Tags","summary":"","title":"Dispatcher Servlet"},{"content":"","date":"3 April 2024","permalink":"/tags/filter/","section":"Tags","summary":"","title":"Filter"},{"content":"","date":"3 April 2024","permalink":"/tags/servlet/","section":"Tags","summary":"","title":"Servlet"},{"content":"","date":"3 April 2024","permalink":"/tags/servlet-container/","section":"Tags","summary":"","title":"Servlet Container"},{"content":"","date":"3 April 2024","permalink":"/tags/spring/","section":"Tags","summary":"","title":"Spring"},{"content":"","date":"3 April 2024","permalink":"/tags/spring-boot/","section":"Tags","summary":"","title":"Spring Boot"},{"content":"🔖 Explore Topics with Ease!\nWelcome to my tags page, where I\u0026rsquo;ve neatly organized posts for your convenience. Whether you\u0026rsquo;re into server, artificial intelligence, or boosting productivity, my tags make finding what you want a piece of cake.\nJust click a tag, and voilà! You\u0026rsquo;ll unlock a bunch of related reads. It\u0026rsquo;s like having your very own map to a world of tech topics. Enjoy exploring! 🚀📚\n","date":"3 April 2024","permalink":"/tags/","section":"Tags","summary":"🔖 Explore Topics with Ease!","title":"Tags"},{"content":"","date":"3 April 2024","permalink":"/tags/thread-pool/","section":"Tags","summary":"","title":"Thread Pool"},{"content":"","date":"3 April 2024","permalink":"/tags/was/","section":"Tags","summary":"","title":"WAS"},{"content":"","date":"3 April 2024","permalink":"/tags/web-server/","section":"Tags","summary":"","title":"Web Server"},{"content":"I\u0026rsquo;m a software engineer with a keen interest in server and artificial intelligence engineering. I thrive on exploring new technologies and embracing challenges, always enjoying the process of learning and building.\nAdditionally, I\u0026rsquo;m deeply fascinated by tools that enhance productivity. Actively exploring and implementing various tools and methods to optimize development processes and work efficiently is something I\u0026rsquo;m passionate about.\nOn this blog, I\u0026rsquo;ll be sharing my experiences with technical challenges, insights into new technologies, and a variety of tips and tricks for boosting productivity. Thank you for joining me on this journey of growth and learning! 🚀\n","date":"3 April 2024","permalink":"/","section":"Welcome to My Technical Blog! 🎉","summary":"I\u0026rsquo;m a software engineer with a keen interest in server and artificial intelligence engineering.","title":"Welcome to My Technical Blog! 🎉"},{"content":" 스프링 부트를 사용하다 보면 사실 스프링 내부에서 어떤 동작이 이루어지는지 모르더라도 원하는 비즈니스 로직 구현을 할 수 있다. 그렇기 때문에 쉽고 간편하게 서버 개발을 할 수 있지만, 결국 언젠가는 클라이언트의 요청이 정확히 어떤 방식으로 처리되는 것인지를 알아야 하는 때가 오게 되는 것 같다. 필자 또한 어느 순간부터 스프링 내부 구조와 데이터 전달/처리 과정을 공부해 봐야겠다는 필요성을 느끼게 되었고 이를 정리하는 글을 작성하게 되었다.\n우선 이 글에서 다루게 될 내용의 전체 모식도는 아래와 같다. 앞으로 각 단계에 해당하는 내용들을 차근차근 살펴볼 예정인데, 계속 이 그림으로 다시 올라오면서 지금 읽고 있는 개념이 어떤 흐름 속에 있는 것인지 확인하기를 바란다. 전체적인 맥락을 파악하며 공부해야 각 세부 정보들에 대한 이해도 더 쉽게 해낼 수 있다.\nAn overview diagram illustrating the entire flow 본격적으로 그림을 살펴보자. 사용자가 서버로 HTTP 요청을 보내면 가장 먼저 이 정보는 웹 서버(Web Server)라는 곳으로 전달된다. 위 그림에서도 볼 수 있듯이 클라이언트의 요청은 우선 웹 서버로 전달되고, 이어서 그 옆에 비슷한 이름을 가진 웹 애플리케이션 서버(WAS, Web Application Server)로 연결된다. 각각의 두 서버는 유사해 보이지만 서로 다른 역할과 기능을 수행한다.\n1. Web Server와 WAS(Web Application Server) # 웹 서버(Web Server)와 웹 애플리케이션 서버(WAS, Web Application Server)는 가장 직관적으로 \u0026ldquo;Application\u0026ldquo;이라는 단어의 유무로 구분된다. 이 단어의 차이로 각각의 서버가 처리할 수 있는 범위와 수행하는 역할의 근본적인 차이가 있음을 알 수 있다.\nApplication, 즉 \u0026ldquo;응용\u0026quot;을 수행할 수 있는 웹 애플리케이션 서버(WAS)는 클라이언트와 상호작용을 통해 동적인 콘텐츠를 생성하여 제공한다. 클라이언트가 요청한 데이터를 처리하기 위해 데이터베이스에 접근하거나, 복잡한 비즈니스 로직을 실행하는 중요한 역할을 담당한다. 톰캣(Tomcat)은 WAS의 대표적인 예로, 스프링 부트를 사용한 경험이 있다면 톰캣이 내장되어 별도의 설정 없이 사용해 왔을 것이다.\n반면 웹 서버(Web Server)는 WAS와 달리 정적인 콘텐츠를 제공하는 역할을 한다. 웹 브라우저와 같은 클라이언트로부터 HTTP 요청을 받으면 HTML 문서, 파일, 이미지 등과 같은, 응답 내용에 변함이 없는 콘텐츠들을 제공해 주는 일을 한다. 대표적인 웹 서버로는 아파치(Apache)와 엔진엑스(Nginx)가 있다.\n사실 WAS는 웹 서버가 수행하는 정적 콘텐츠 제공의 역할까지 수행할 수 있다. 하지만 위의 전체 흐름 모식도에도 나와 있듯이 보통 웹 서비스는 WAS 앞에 웹 서버를 붙여서 같이 사용하곤 한다. 왜 굳이 WAS만으로도 충분한 것 같은데 웹 서버를 함께 사용하는 것일까? 그 이유는 여러 가지가 있는데 가볍게 살펴보면 다음과 같다.\n우선 웹 서버는 정적 콘텐츠를 처리하는 것에 최적화되어 있기 때문에 각각의 서버가 역할을 분리하여 부담을 줄이고 부하를 분산 할 수 있다는 장점이 있다. 또한 웹 서버는 로드 밸런서의 역할을 수행할 수 있다. 로드 밸런서란 말 그대로 서버에 가해지는 부하(로드)를 분산(밸런싱)해주는 장치를 의미한다. 여러 WAS가 배포되어 있는 경우, 웹 서버는 들어오는 요청을 각 서버에 적절하고 균형 있게 분산해주는 일을 수행한다. 또한 웹 서버는 리버스 프록시 역할을 하여 외부와 내부 네트워크를 격리시킬 수 있다. 리버스 프록시는 클라이언트와 서버 간 중개자 역할을 하는 서버로, 직접적인 접근을 방지하여 전체 서비스의 보안을 강화해주는 역할을 수행한다.\n정리를 해보자면, 클라이언트의 요청이 들어오면 우선 웹 서버에서 정적인 콘텐츠들에 대한 처리가 진행되고 이후 WAS로 요청이 전달되어 동적 콘텐츠를 반환해주는 것이다. 그러면 이제 조금 더 구체적으로 WAS에서 HTTP 요청에 대한 처리를 어떻게 진행하는지를 알아보도록 하자.\n2. 서블릿 컨테이너(Servlet Container)와 서블릿(Servlet) # 다시 위의 전체 흐름 모식도를 살펴보고 오자. WAS 안에 서블릿 컨테이너(Servlet Container)라는 것이 보인다. 개발 공부를 하다 보면 컨테이너(Container)라는 용어를 자주 마주하게 된다. 그 의미를 먼저 짚고 넘어가자면 말 그대로 무언가를 담고 있는 것을 의미한다. 하지만 단순히 무언가를 모아놓은 것에서 역할이 끝나는 것이 아니라 이들을 관리하는 기능까지 수행한다. 즉, 서블릿 컨테이너는 서블릿이라는 것을 담아두고 관리하는 무언가라고 생각하면 된다.\n그렇다면 서블릿이란 뭘까?\nA servlet is a Java programming language class that is used to extend the capabilities of servers that host applications accessed by means of a request-response programming model.\nJavaEE 공식 문서에 적혀있는 서블릿에 대한 정의이다. 한국어로 번역해 보면 다음과 같다.\n\u0026lsquo;서블릿은 요청-응답 프로그래밍 모델을 통해 접근되는 애플리케이션을 호스트하는 서버의 기능을 확장하는 데 사용하는 자바 클래스이다.\u0026rsquo;\n문장이 뭔가 어렵게 쓰여 있지만 정리하자면, 클라이언트와 상호작용을 하는 동적 애플리케이션을 만들기 위해서는 요청을 처리하기 위한 기술들이 필요한데, 그 기술의 기반이 되는 로우 레벨 코드를 제공해주는 클래스를 뜻한다고 보면 된다. 웹 애플리케이션의 경우 HTTP 프로토콜을 통해 주고받는 데이터에서 통신에 필요한 여러 부가적인 것들을 읽고 처리해주는 역할을 하는 것이라고 생각하면 된다.\n실제 서블릿을 동작하기 위해서는 특정 URL에 특정 서블릿 객체를 매핑하여 설정해주면 된다. 개발자는 XML 파일을 만들어 각각의 매핑 정보를 작성하거나 어노테이션을 이용하는 방식을 사용할 수 있다. 따라서 만약 HTTP 요청이 오면 WAS의 서블릿 컨테이너는 우선 요청 URL에 맞는 서블릿 매핑 정보를 확인하여 맞는 서블릿 객체를 (새로 만들거나) 호출한다. 이때 WAS는 HTTP 요청 정보로부터 Request 객체를 만들어 함께 서블릿 객체에 전달하고 이어서 비즈니스 로직을 수행하게 된다. 그리고 모든 작업이 끝나면 응답 정보를 Response 객체에 담아 클라이언트에게 보낸다.\n3. Dispatcher Servlet # 실제로 스프링 MVC에서는 서블릿 객체를 싱글톤으로 관리한다. Dispatcher Servlet이라는 모든 요청을 담당하는 서블릿을 하나 두고 나머지 처리는 컨트롤러(Controller)에게 위임한다. 이를 프론트 컨트롤러(Front Controller) 디자인 패턴이라고 하는데, 이를 통해 개발자는 서블릿을 직접 다루지 않아도 클라이언트의 요청을 처리할 수 있게 된다. Dispatcher Servlet을 통해 스프링 컨테이너 안의 요소들로 접근할 수 있는 연결이 생기고, 서버 개발자가 작성한 비즈니스 로직 코드가 실행될 수 있게 되는 것이다.\n다시 맨 앞의 그림을 살펴보고 오자. 이제 어느 정도 흐름이 파악되기 시작할 것이다. 스프링 컨테이너 안에서의 흐름을 마무리 정리해 보자면, Dispatcher Servlet은 Handler Mapping을 통해 매핑된 컨트롤러를 조회한다. 이후 Handler Adapter로 해당 컨트롤러에 요청 내용을 전달하고 이는 Service, Repository 단에서 처리되어 응답 결과를 반환한다. 최종적으로 결과 출력을 위해선 ViewResolver가 호출되어 사용된다.\n4. 스레드 풀(Thread Pool)과 필터(Filter) # 이제 마지막으로 설명을 하지 않고 넘어간 쓰레드 풀과 필터에 대해 간략하게 설명하려고 한다.\n서블릿 컨테이너의 역할을 다시 한번 떠올려보면, 서블릿 객체의 생성, 호출, 소멸 등의 라이프사이클을 직접적으로 관리해주는 일을 수행한다. 하지만 이외에도 서블릿 컨테이너는 다양한 중요한 작업들을 처리하는 역할을 한다.\n우선 웹 서버와의 통신을 가능하게 해주는 중요한 역할을 한다. 클라이언트의 요청을 받고 응답할 수 있도록 웹 서버와 소켓을 만들어 통신을 지원한다. 또한 요청을 받을 때마다 스레드를 할당하여 멀티스레드로 효율적인 운영을 할 수 있도록 지원한다. 이때 스레드 풀(Thread Pool)이라는 개념이 등장하는데 자세히 살펴보자.\n4.1. 스레드 풀(Thread Pool) # Diagram of how a thread pool executor works 클라이언트의 요청이 들어오면 각 요청에 대해 처리해 줄 스레드가 하나씩 할당되고 이후 Dispatcher Servlet을 거쳐 요청이 처리된다. 이때 톰캣은 매번 새로운 스레드를 생성하는 대신, 미리 다수의 스레드를 만들어놓고 필요할 때마다 이 중에서 하나를 꺼내 사용하는 방식을 취한다. 이렇게 미리 생성해 둔 스레드들의 집합을 스레스 풀(Thread Pool)이라 한다. 매번 스레드를 생성하고 소멸하는 것은 운영체제나 JVM에 상당한 부담을 주며, 특히 동시에 다수 요청이 들어오는 경우 리소스(메모리, CPU)의 소모를 효율적으로 관리하기 어렵기 때문에 스레드 풀 개념이 도입되었다.\n스레드 풀에 대한 설정은 application.yml 파일에서 수정할 수 있다. 아래는 기본값으로 설정된 수치를 나타낸 것이다. 각자의 상황에 맞게 수정하여 사용하면 되고, 기본값 그대로 사용한다면 기본 세팅 값을 대략이라도 알아두도록 하자.\nserver: tomcat: threads: max: 200 # 생성할 수 있는 thread의 총 개수 min-spare: 10 # 항상 활성화 되어있는 thread의 개수 max-connections: 8192 # 수립가능한 connection의 수 accept-count: 100 # 작업 큐의 사이즈 (default : Integer.MAX) connection-timeout: 20000 # 커넥션 유지시간 4.2. 필터(Filter) # 어쩌다 보니 이 내용을 가장 마지막으로 작성하게 되었지만, 사실 필터를 이해하기 위해 이 글을 처음 작성하기 시작했다. 토이 프로젝트를 진행하면서 JWT 인증을 구현할 일이 생겼는데, 그 과정에서 인증 필터를 적용하게 되면서 처음으로 필터 개념을 접하게 되었다. 처음에는 필터가 무엇인지, 어떤 역할을 하는 것인지 이해해 보고자 공부를 시작하였지만, 연관된 구성 요소들을 공부하다 보니 자연스럽게 그 범위가 확장되었고 스프링 애플리케이션의 전반적인 구조를 살펴보게 되었다.\n결국 필터는 Dispatcher Servlet과 클라이언트 사이에서 요청/응답 데이터에 처리해야 할 부가 작업을 처리하는 기능을 하는 것이라고 보면 된다. 그렇기 때문에 요청과 응답의 순수한 정보를 확인할 수 있고 이를 알맞은 형태로 변환하는 역할을 수행한다. 따라서 주로 로깅 용도로 활용하거나 인증과 관련된 로직을 처리하는 데 활용한다. 요청 데이터를 변경하거나 응답에 특정 헤더를 추가하는 역할을 수행하기도 한다.\n사실 필터는 J2EE표준 스펙 기능으로 스프링 프레임워크와는 별개의 기술이지만, 스프링 빈으로 등록할 수 있다. 스프링 부트가 서블릿 컨테이너까지 제어 가능하기 때문인데, 구체적인 내용은 추후에 또 다뤄보기로 하자.\n이번 글을 작성하며 스프링 프레임워크에서 클라이언트의 요청을 어떻게 처리하는지 대략적인 과정을 살펴보았다. 전체적인 흐름을 담으려고 많이 노력했기 때문에 세부적인 내용을 전부 담지는 못했다. 그래서 부족한 부분이 아직 많은데, 앞으로 계속 공부하면서 차근차근 채워나갈 예정이다.\n🛠️ Reference https://dip-mazumder.medium.com/how-to-determine-java-thread-pool-size-a-comprehensive-guide-4f73a4758273 https://velog.io/@sihyung92/how-does-springboot-handle-multiple-requests https://souljit2.tistory.com/73 https://taes-k.github.io/2020/02/16/servlet-container-spring-container/ https://sigridjin.medium.com/servletcontainer%EC%99%80-springcontainer%EB%8A%94-%EB%AC%B4%EC%97%87%EC%9D%B4-%EB%8B%A4%EB%A5%B8%EA%B0%80-626d27a80fe5 ","date":"3 April 2024","permalink":"/posts/spring_overall/","section":"Posts","summary":"스프링 부트를 사용하다 보면 사실 스프링 내부에서 어떤 동작이 이루어지는지 모르더라도 원하는 비즈니스 로직 구현을 할 수 있다.","title":"스프링(Spring) 뜯어보기 : 클라이언트의 요청은 서버에서 어떻게 처리될까?"},{"content":"","date":"24 January 2024","permalink":"/tags/db/","section":"Tags","summary":"","title":"DB"},{"content":"","date":"24 January 2024","permalink":"/tags/jpa/","section":"Tags","summary":"","title":"JPA"},{"content":"","date":"24 January 2024","permalink":"/tags/lock/","section":"Tags","summary":"","title":"Lock"},{"content":"","date":"24 January 2024","permalink":"/tags/transaction/","section":"Tags","summary":"","title":"Transaction"},{"content":" 한 유명 레스토랑에서 새로운 예약 시스템을 도입하여 매일 오후 5시마다 다음 날 예약 손님 50명을 받기로 결정했다. 해당 서비스의 도입 첫날, 사람들은 마치 인기 가수의 콘서트 티켓팅을 하는 것처럼 5시만을 기다리고 있다가 동시에 예약 신청을 했고 순식간에 예약이 마감되었다. 그렇게 새로 도입한 시스템은 안정적으로 작동된 줄 알았지만, 가게 주인이 예약을 성공한 손님들의 리스트를 확인해 보니 처음 계획한 50명을 넘어서 68명의 손님이 예약되어 있었다! 가게에는 앉을 수 있는 자리가 한정되어 있고 준비된 재료도 제한되어 있기 때문에 어쩔 수 없이 가게 주인은 몇몇 손님들께 양해를 구하며 강제로 예약을 취소할 수밖에 없었다.\n이건 데이터베이스 시스템의 무결성을 유지하는 것이 얼마나 중요한지를 말하기 위해 각색한 이야기이다. 예약 신청 요청이 들어오면 설정해 놓은 정원에서 인원수를 정확히 차감하여 현재 남은 자릿수를 계산해야 한다. 하지만 데이터베이스 값을 읽고 쓰는 과정에서 무결성과 동시성을 제대로 제어하지 못하면 위와 같은 문제 상황이 발생할 수 있다. 만약 피해 규모가 더 크고 사안이 더 심각한 실제 비즈니스 상황이었다면, 기업의 신뢰성은 물론이고 손님들의 만족도 또한 크게 하락하여 큰 문제로 이어질 수도 있었을 것이다. 이러한 끔찍한 상황을 피하기위해, 우리는 데이터베이스 시스템에서 트랜잭션과 락에 대해 제대로 이해하고 사용할 줄 알아야 한다. 그럼, 본격적으로 트랜잭션에 대해 먼저 알아보도록 하자.\n1. 트랜잭션(Transaction)이란 무엇일까? # 쇼핑몰 사이트에서 물건을 하나 주문할 때 내부에서 어떤 로직이 실행되고 데이터베이스에 정보가 저장되는지를 생각해 보자. 해당 상품에는 정해져 있는 한정된 재고량이 있을 것이고, 소비자의 주문 요청이 들어오면 요청 수량만큼 차감되어 값이 갱신되고 새로운 주문 접수가 이루어질 것이다. 그러면 백엔드 개발자 입장에서는 주문 요청이 들어왔을 때,\n주문 요청 들어온 수만큼 상품 재고 차감 후 DB에 값 업데이트 새로운 주문 정보 저장 이 두 가지 일을 처리하게 된다. 이와 같이 데이터베이스의 상태를 변화시키는 작업에는 일련의 연산들이 하나의 작업 단위로 묶여 처리되곤 하는데, 이 논리적 작업 단위를 트랜잭션이라 한다.\n이 정도의 설명으로 트랜잭션의 간단한 개념 정도는 파악할 수 있다. 하지만 막상 프로젝트를 진행하려고 하면 \u0026lsquo;그래서 트랜잭션이 실제 코드상에선 어떻게 동작한다는 건데?\u0026rsquo;, \u0026lsquo;어느 범위까지 트랜잭션을 통해 관리가 된다는 거지?\u0026rsquo; 등과 같은 의문이 생긴다. 제대로 이해하지 않은 채 무작정 @Transactional만 붙이고 코드를 작성하다 보면, 문제가 생겨도 원인을 찾지 못하고 오랜 시간을 헤매게 될 수 있다. 그래서 스프링 컨테이너에서의 트랜잭션을 조금 더 자세하게 알아보려고 한다.\n1.1. 트랜잭션은 구체적으로 어떻게 동작하는 걸까? # 트랜잭션의 동작 방식을 알아보기 전에 우선 영속성 컨텍스트를 알아야 한다. 스프링 공부를 해봤다면 아마 이 개념을 많이 들어봤을 것이다. 간단히 말해서 영속성 컨텍스트는 데이터베이스로부터 데이터를 읽어온 후 이를 객체로 변환하고 메모리에 유지하며 관리하는 역할을 하는 것이라고 할 수 있다. 멀리 저장되어 있는 정보를 가까이 가져와 조금 더 빠르고 쉽게 관리하며 사용하는 것이라고 간단히 생각해 볼 수 있겠다.\n스프링 컨테이너에서 트랜잭션의 범위는 영속성 컨텍스트의 생존 범위와 같다. 조금 더 풀어서 설명하자면, @Transactional 어노테이션이 붙어있는 메소드를 실행할 때 먼저 트랜잭션이 시작되어 영속성 컨텍스트가 생성되고, 해당 메소드가 정상 종료되면 트랜잭션을 커밋하면서 영속성 컨텍스트도 종료된다. 같이 실행되어 생성되었다가 같이 종료되는 것이다. 아래 그림과 예제를 보면 트랜잭션의 범위와 동작 순서를 더 쉽게 이해할 수 있을 것이다. Illustration of the scope of transaction @Service @RequiredArgsConstructor class HelloService { private final HelloRepository memberRepository; // 1. 트랜잭션 시작 -\u0026gt; 영속성 컨텍스트 생성 @Transactional public void hello() { // 2. member는 영속 상태 Member member = memberRepository.findMember(); return member } // 3. 트랜잭션 종료 -\u0026gt; 영속성 컨텍스트 종료 } @Repository @RequiredArgsConstructor class HelloRepository { private final EntityManager em; public Member findMember(){ return em.find(Member.class, \u0026#34;id1\u0026#34;); // 영속성 컨텍스트 접근 } } 예제를 보며 차근차근 과정을 따라가 보자.\n어떤 Controller에서 HelloService의 hello() 메소드를 호출하면 트랜잭션이 먼저 실행된다. memberRepository로 조회한 member 엔티티는 트랜잭션 범위 안에 속해 있으며, 영속성 컨텍스트에 의해 관리된다. 해당 메소드가 정상적으로 종료되면 트랜잭션도 커밋하고 종료하게 되는데, 이때 JPA는 먼저 영속성 컨텍스트를 플러시 해서 데이터베이스에 변경 사항을 반영한 후, 데이터베이스 트랜잭션을 커밋한다. 만약 예외가 발생했다면 트랜잭션을 롤백하고 종료하고, 이때는 플러시를 호출하지 않는다. 이와 같은 방식으로 작동하는 트랜잭션이 가지는 한 가지 특징이 있다.\n트랜잭션이 같으면 같은 영속성 컨텍스트를 사용하고, 트랜잭션이 다르면 다른 영속성 컨텍스트를 사용한다.\n당연한 얘기를 하고 있는 것 같지만 꽤 중요한 특징이라고 할 수 있다. 스프링 컨테이너는 여러 스레드에서 동시에 요청이 오면 각 스레드마다 다른 트랜잭션을 할당한다. 따라서 같은 엔티티 매니저를 사용하고 있다고 해도 트랜잭션이 다르면 (스레드가 다르면) 다른 영속성 컨텍스트를 사용하게 된다. 그래서 멀티스레드 환경에서도 안전하게 동작할 수 있다. 스프링 컨테이너는 이와 같이 복잡한 멀티 스레드 상황을 알아서 처리해 주기 때문에, 개발자들은 싱글 스레드 환경처럼 생각하고 단순하게 개발할 수 있게 된다. Illustration of the multi-thread condition 1.2. ACID 특성 # 트랜잭션의 개념을 설명할 때 거의 빠지지 않고 등장하는 중요한 속성이다. ACID는 원자성Atomicity, 일관성Consistency, 격리성Isolation, 지속성Durability을 의미하며 데이터베이스 트랜잭션의 안전성을 위해 보장하기 위해 꼭 지켜져야 하는 성질이다. 이 글에서 다루고 싶은 내용은 격리성Isolation이기 때문에 다른 특성들은 가볍게 정리하고 넘어가려고 한다.\n원자성 : All or Nothing. 트랜잭션 내에서 실행한 작업들은 부분적으로 실행될 수 없고, 모두 성공하거나 모두 실패해야 한다. 일관성 : 트랜잭션이 완료되었을 때 항상 일관성 있는 데이터베이스 상태를 유지해야 한다. 데이터베이스에서 정한 무결성 제약 조건들을 항상 지켜야 한다. 격리성 : 동시에 트랜잭션이 실행되었을 때, 서로에게 영향을 주지 않도록 격리해야 한다. 지속성 : 성공적으로 끝난 트랜잭션의 결과가 항상 기록되어야 한다. 트랜잭션은 다양한 방법들(롤백 세그먼트, 트리거 등)을 이용해서 원자성, 일관성, 지속성을 보장한다. 그 구체적인 방법들은 다음에 자세히 다뤄보기로 하고 우선 격리성에 집중해 보자.\n트랜잭션의 격리성을 완벽하게 보장하기 위해서는 각각의 트랜잭션을 하나씩 차례로 실행하는 방법이 있는데, 이 경우에는 동시성 처리 성능이 매우 떨어지게 된다. 반대로 동시성 처리 성능을 높이려고 하면 데이터베이스 정보를 다룰 때 서로에게 영향을 끼쳐 여러 문제가 발생할 수 있다는 위험이 있다. 따라서 적용하고자 하는 비즈니스 로직에 따라 격리 수준을 다르게 설정하여 적용해 주어야 하고, 발생할 수 있는 문제들을 확실히 인지하여 알맞게 대응해야 한다.\n트랜잭션의 격리 수준isolation level은 ANSI 표준에 따라 다음과 같이 4단계로 나누어 정의된다. 각 수준에 따라 발생할 수 있는 문제점들과 함께 정리하여, 어떤 상황에서 어떤 수준이 적합할지를 직접 느껴보면 좋을 것 같다.\n격리 수준 Dirty Read Non-Repeatable Read Phantom Read Read Uncommitted O O O Read Committed O O Repeatable Read O Serializable 위 표의 순서대로 Read Uncommitted의 격리 수준이 가장 낮고 Serializable이 가장 높다. 하나씩 자세히 살펴보자.\nRead Uncommitted 영어 번역 그대로, 커밋하지 않은 데이터를 읽을 수 있다는 것이다. 즉 어떤 트랜잭션에서 데이터를 수정했고 아직 커밋이 완료되지 않은 상태지만, 다른 트랜잭션에서 수정된 데이터를 조회할 수 있다는 것이다. 위 예에서와 같이 트랜잭션 2에서 y 값을 수정한 후 아직 커밋하지 않았음에도 트랜잭션 1에서 수정 중인 데이터를 조회할 수 있다. 이를 Dirty Read라고 하는데, 트랜잭션 2에서 롤백하는 상황이 생기면 y 값은 1로 다시 돌아오는 반면, x 값은 트랜잭션 1에서 이미 바뀐 y의 값으로 연산이 진행되기 때문에 2 대신 6으로 처리된다. 따라서 이 경우 데이터 정합성에 심각한 문제가 발생할 수 있다.\nRead Committed 커밋한 데이터만을 읽을 수 있다. 따라서 위와 같은 Dirty Read 문제는 발생하지 않는다. y 값이 중간에 변경되어도 커밋이 완료되지 않았다면 다른 트랜잭션에서 조회되지 않기 때문이다. 대신 Non-Repeatable Read 문제가 발생한다. 위 그림에서와 같이 트랜잭션 1에서는 x를 두 번 읽는 작업을 하고, 트랜잭션 2에서는 x 값을 수정하는 작업이 진행되는 상황을 떠올려보자. 만약 트랜잭션 1에서 x 읽기 한 번을 수행한 후에 트랜잭션 2의 수정 작업이 모두 끝나 커밋까지 완료했다면, 두 번째 x 값을 읽을 때는 이전 결과와 다른 값이 조회될 것이다. 이처럼 한 트랜잭션 안에서 읽었음에도 값이 달라지는 경우를 Non-Repeatable Read라 한다.\nRepeatable Read 트랜잭션 안에서 한 번 조회한 데이터를 반복해서 조회하면 같은 데이터가 읽힌다. 하지만 추가적으로 이전에 없었던 데이터가 새로 생기는 현상이 발생할 수는 있다. 이를 Phantom Read 문제라 한다. 위의 예에서 트랜잭션 1은 val 값이 10인 데이터를 두 번 읽는 작업을 수행하고 트랜잭션 2에서는 m2 객체의 val 값을 10으로 바꾸는 작업을 한다. 트랜잭션 1에서 한 번 읽기 작업이 수행되면 m1 객체가 조회된다. 하지만 두 번째 읽기 작업이 시작되기 전에 트랜잭션 2에서 커밋이 완료되면, m1과 m2 모두 val 값이 10이 되기 때문에 m2 객체 하나가 추가되어 첫 번째 조회 결과 집합과 달라지게 된다.\nSerializable 트랜잭션을 그냥 순차적으로 진행시킨다. 가장 엄격한 격리 수준을 가지며 동시 처리 성능이 매우 떨어진다.\n글을 읽다 보면 느낄 수 있듯이 트랜잭션 격리 작업은 데이터베이스 처리의 가장 기본이 되는 것 중 하나이다. 따라서 각 오픈소스 데이터베이스(MySQL, PostgreSQL, MariaDB 등)에서는 기본으로 사용하고 있는 격리 수준을 명시하고 있고, 사용자가 직접 지정할 수도 있도록 지원하고 있다. 그렇다면 스프링 프레임워크에서는 어떤 방식으로 설정이 되어 있는지 궁금해져 Transactional 어노테이션을 살펴보았다. Transactional 안에 Isolation은 기본 DEFAULT로 설정되어 있고, 초록색 주석 부분을 읽어보면 이 DEFAULT는 underlying datastore, 즉, 사용하고 있는 데이터베이스 격리 수준을 그대로 따르도록 설정되어 있음을 확인할 수 있었다. Code of @Transactional Code of Isolation 대부분의 애플리케이션에서는 동시성 처리가 중요하기 때문에 Read Committed를 사용하고 Repeatable Read도 많이 선택한다. 하지만 더 높은 수준의 격리가 필요한 비즈니스 로직에는 데이터베이스 트랜잭션이 제공하는 락(Lock) 기능을 추가로 사용하게 되는데, 이어서 자세히 살펴보려고 한다.\n2. 더 높은 격리 수준이 필요하다면, 락(Lock)을 사용하자 # 앞에서 언급한 트랜잭션 격리 수준이 전부는 아니다. Read Committed 격리 수준을 사용해도 락(Lock)을 이용하면 Repeatable Read(반복 가능한 읽기)가 가능하게 만들 수 있다. 구체적으로 살펴보면, 우선 락의 종류에는 낙관적 락(Optimistic Lock)과 비관적 락(Pessimistic Lock)이 있다.\n2.1. 낙관적 락(Optimistic Lock) # 낙관적 락은 이름을 통해서도 알 수 있듯이, 대부분의 트랜잭션에서 충돌이 발생하지 않을 것이라고 낙관적으로 가정한 상태에서 충돌에 대비하는 방식이다. 충돌이 발생하지 않을 것이라고 가정했기 때문에 일단 작업을 진행했다가 커밋할 때 충돌이 일어났는지를 확인하게 된다. 낙관적 락은 JPA가 제공하는 버전 관리 기능을 사용하여 동작하고 @Version 어노테이션을 통해 간단히 구현할 수 있다.\n@Entity public class Board { @Id private String id; private String title; @Version private Integer version; } 버전 관리 기능은 위의 예처럼 락을 적용하고자 하는 엔티티에 버전용 필드를 하나 만들고 위에 @Version 어노테이션만 붙여주면 된다. 해당 필드의 타입은 Integer 외에도 Long, Short, Timestamp가 가능하다. 버전을 이용해서 충돌을 인지하는 방법은 매우 단순하다. 우선 엔티티의 상태가 변경될 때마다 버전이 자동으로 하나씩 증가한다. 그리고 엔티티를 수정할 때는 처음 조회 시점의 버전과 커밋할 때 마지막 시점의 버전을 비교하여 그 값이 다르면 예외가 발생한다. 예를 들어 만약 트랜잭션 1에서 Board 엔티티를 수정하는 도중, 동시에 트랜잭션 2에서 같은 엔티티를 수정하고 커밋하여 버전이 증가해 버렸다면, 트랜잭션 1의 마지막 커밋 시점에서 바뀐 버전 정보가 읽히기 때문에 예외가 발생하게 된다. 아래 예에서는 트랜잭션 2에서 title 값이 변하면서 버전이 2로 증가했기 때문에, Transaction 1에서 예외가 발생하게 된다. 따라서 낙관적 락에서와 같이 버전 정보를 사용하게 되면 최초의 커밋만을 인정하는 방식으로 작동한다. 조금 더 구체적으로 보면, 엔티티 수정 후 트랜잭션을 커밋하면 영속성 컨텍스트를 플러시 하면서 UPDATE 쿼리가 실행된다.\nUPDATE BOARD SET TITLE=\u0026#39;B\u0026#39;, VERSION=2 (버전 증가하기) WHERE ID=1, AND VERSION=1 UPDATE 쿼리는 다음과 같이 구성되는데 WHERE 문을 통해 기존 버전과 값을 비교하고 값이 같으면 버전을 하나 증가시키고 아니면 예외를 발생시킨다.\n기본적으로 @Version만 적용했을 때는 엔티티의 값에 수정이 생겼을 때 버전이 증가한다. 만약 엔티티를 조회만 해도 버전을 체크하고 싶다면, OPTIMISTIC 옵션을 추가해 주면 된다. 이 방식을 사용하면 Dirty Read와 Non-Repeatable Read를 방지할 수 있다는 이점이 있다. 또한, 연관관계 필드의 경우 외래 키를 관리하는 연관관계의 주인 필드를 수정할 때만 버전이 증가한다. 만약 강제로 버전 정보를 증가하여 원하는 대로 관리하고 싶다면 OPTIMISTIC_FORCE_INCREMENT 옵션을 사용해 주면 된다.\n2.2. 비관적 락(Pessimistic Lock) # 비관적 락은 트랜잭션의 충돌이 발생할 것이라고 비관적으로 가정하여 우선 락을 걸고 보는 방법이다. JPA의 버전 관리 기능을 사용하는 낙관적 락과 달리 데이터베이스가 제공하는 락 메커니즘을 사용하며, 데이터 수정 즉시 충돌을 감지하게 된다. 대표적으로 SQL 쿼리의 select for update 구문을 사용하며 시작한다.\n비관적 락에는 PESSIMISTIC_WRITE, PESSIMISTIC_READ 옵션이 있는데, 일반적으로는 PESSIMISTIC_WRITE 모드를 사용한다.\nPESSIMISTIC_WRITE 데이터베이스에 쓰기 락을 거는 옵션이다. 쉽게 생각하면, \u0026lsquo;나 데이터 쓰기 작업하려고 락(Lock) 걸거야!\u0026lsquo;라고 선언하는 것이라 생각하면 된다. 따라서 트랜잭션 1에서 쓰기 락을 가져갈 경우, 트랜잭션 2에서는 해당 데이터가 변경될 수 있기 때문에 락이 풀릴 때까지 읽기, 쓰기 둘 다 불가능하다. PESSIMISTIC_READ 데이터베이스에 읽기 락을 거는 옵션이다. 쓰기 락과는 달리 \u0026lsquo;나 데이터 읽기 작업하려고 락(Lock) 걸 거야!\u0026lsquo;로 이해하면 쉽다. 따라서 트랜잭션 1에서 읽기 락을 가져갈 경우, 트랜잭션 2에서 해당 데이터를 읽는 것은 데이터의 일관성에 아무런 문제가 없기 때문에 가능하다. 하지만 데이터를 쓰는 것은 값에 변화가 생겨 트랜잭션 1과 달라질 수 있으므로 불가능하다. 길고 긴 여정을 통해 트랜잭션과 락에 대한 기본 지식을 익히는 시간을 가졌다. 중간중간 생략하거나 넘어간 설명들이 있었지만, 이 정도면 주요한 개념들을 이해하는 데 큰 도움이 되었을 것이라 생각한다. 이 여정의 결론에서 도달한 핵심은 \u0026lsquo;데이터베이스 관리에서 동시성과 무결성 사이의 적절한 균형이 중요하다\u0026rsquo;는 것이다. 그리고 이 균형을 설정하고 유지하기 위해서는 트랜잭션과 락을 제대로 이해하고 적절하게 활용할 줄 알아야 한다. 글을 써가며 최대한 예를 들어 설명을 자세히 적으려고 노력했다. 이를 통해 자신의 프로젝트 상황에 따라 잘 판단하여 현명하게 데이터베이스를 관리할 수 있기를 바란다.\n","date":"24 January 2024","permalink":"/posts/transaction_lock/","section":"Posts","summary":"한 유명 레스토랑에서 새로운 예약 시스템을 도입하여 매일 오후 5시마다 다음 날 예약 손님 50명을 받기로 결정했다.","title":"트랜잭션과 락 이해하기 : 데이터베이스 관리의 핵심, 동시성과 무결성의 균형잡기"},{"content":"","date":"13 June 2022","permalink":"/posts/","section":"Posts","summary":"","title":"Posts"},{"content":"","date":"1 January 0001","permalink":"/authors/","section":"Authors","summary":"","title":"Authors"},{"content":"","date":"1 January 0001","permalink":"/categories/","section":"Categories","summary":"","title":"Categories"},{"content":"","date":"1 January 0001","permalink":"/series/","section":"Series","summary":"","title":"Series"}]